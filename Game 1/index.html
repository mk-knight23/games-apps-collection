<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zombie Plant Defenders</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        canvas {
            border: 3px solid #fff;
            border-radius: 10px;
            display: block;
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8C8 100%);
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
            color: white;
        }

        .game-title {
            font-size: 2.5em;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
            margin-bottom: 10px;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        .game-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 1.2em;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .plant-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
        }

        .plant-btn {
            padding: 10px 15px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .plant-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .plant-btn.selected {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            transform: scale(1.1);
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 1000;
        }

        .game-over h2 {
            font-size: 2em;
            margin-bottom: 20px;
            color: #ff6b6b;
        }

        .restart-btn {
            padding: 15px 30px;
            font-size: 1.2em;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .restart-btn:hover {
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">üå± Zombie Plant Defenders üßü</h1>
            <div class="game-stats">
                <div>‚òÄÔ∏è Sun: <span id="sunCount">50</span></div>
                <div>üßü Wave: <span id="waveCount">1</span></div>
                <div>üí∞ Score: <span id="scoreCount">0</span></div>
            </div>
            <div class="plant-selector">
                <button class="plant-btn selected" data-plant="peashooter">üå± Peashooter (100)</button>
                <button class="plant-btn" data-plant="sunflower">üåª Sunflower (50)</button>
                <button class="plant-btn" data-plant="wallnut">ü•ú Wallnut (50)</button>
                <button class="plant-btn" data-plant="chomper">üåµ Chomper (150)</button>
            </div>
        </div>
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="game-over" id="gameOver">
            <h2>Game Over!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button class="restart-btn" onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameState = {
            sun: 50,
            wave: 1,
            score: 0,
            selectedPlant: 'peashooter',
            gameOver: false,
            plants: [],
            zombies: [],
            projectiles: [],
            suns: [],
            particles: [],
            lastZombieSpawn: 0,
            lastSunSpawn: 0,
            zombieSpawnRate: 5000,
            sunSpawnRate: 10000
        };

        // Plant types
        const plantTypes = {
            peashooter: { cost: 100, health: 100, shootRate: 2000, damage: 20, emoji: 'üå±' },
            sunflower: { cost: 50, health: 100, sunRate: 5000, sunAmount: 25, emoji: 'üåª' },
            wallnut: { cost: 50, health: 300, emoji: 'ü•ú' },
            chomper: { cost: 150, health: 150, eatRate: 3000, damage: 100, emoji: 'üåµ' }
        };

        // Grid system
        const GRID_ROWS = 5;
        const GRID_COLS = 9;
        const CELL_WIDTH = canvas.width / GRID_COLS;
        const CELL_HEIGHT = canvas.height / GRID_ROWS;

        // Plant class
        class Plant {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.health = plantTypes[type].health;
                this.maxHealth = plantTypes[type].health;
                this.lastAction = Date.now();
                this.animation = 0;
            }

            update() {
                this.animation += 0.1;
                
                if (this.type === 'peashooter') {
                    if (Date.now() - this.lastAction > plantTypes.peashooter.shootRate) {
                        this.shoot();
                        this.lastAction = Date.now();
                    }
                } else if (this.type === 'sunflower') {
                    if (Date.now() - this.lastAction > plantTypes.sunflower.sunRate) {
                        this.produceSun();
                        this.lastAction = Date.now();
                    }
                } else if (this.type === 'chomper') {
                    this.checkForZombies();
                }
            }

            shoot() {
                const zombie = this.findZombieInLane();
                if (zombie) {
                    gameState.projectiles.push(new Projectile(
                        this.x + CELL_WIDTH / 2,
                        this.y + CELL_HEIGHT / 2,
                        zombie
                    ));
                }
            }

            produceSun() {
                gameState.suns.push(new Sun(
                    this.x + CELL_WIDTH / 2 + Math.random() * 40 - 20,
                    this.y + CELL_HEIGHT / 2
                ));
            }

            checkForZombies() {
                const zombie = this.findZombieInRange();
                if (zombie && Date.now() - this.lastAction > plantTypes.chomper.eatRate) {
                    zombie.health -= plantTypes.chomper.damage;
                    this.lastAction = Date.now();
                    createParticles(zombie.x, zombie.y, 'üíÄ');
                }
            }

            findZombieInLane() {
                return gameState.zombies.find(z => 
                    Math.abs(z.y - this.y) < 50 && z.x > this.x
                );
            }

            findZombieInRange() {
                return gameState.zombies.find(z => 
                    Math.abs(z.x - this.x) < 80 && 
                    Math.abs(z.y - this.y) < 50
                );
            }

            draw() {
                ctx.save();
                ctx.translate(this.x + CELL_WIDTH / 2, this.y + CELL_HEIGHT / 2);
                
                // Health bar
                const healthPercent = this.health / this.maxHealth;
                ctx.fillStyle = healthPercent > 0.5 ? '#4CAF50' : healthPercent > 0.25 ? '#FFC107' : '#F44336';
                ctx.fillRect(-20, -35, 40 * healthPercent, 5);
                ctx.strokeStyle = '#333';
                ctx.strokeRect(-20, -35, 40, 5);
                
                // Plant emoji with animation
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const bounce = Math.sin(this.animation) * 2;
                ctx.fillText(plantTypes[this.type].emoji, 0, bounce);
                
                ctx.restore();
            }
        }

        // Zombie class
        class Zombie {
            constructor(lane) {
                this.x = canvas.width;
                this.y = lane * CELL_HEIGHT + CELL_HEIGHT / 2;
                this.health = 100 + (gameState.wave - 1) * 20;
                this.maxHealth = this.health;
                this.speed = 0.5 + Math.random() * 0.3;
                this.damage = 10;
                this.lastAttack = 0;
                this.costume = ['üëî', 'üëó', 'üé©', 'üëü', 'ü¶∫'][Math.floor(Math.random() * 5)];
                this.animation = 0;
            }

            update() {
                this.animation += 0.1;
                this.x -= this.speed;
                
                // Check for plant collision
                const plant = gameState.plants.find(p => 
                    Math.abs(p.x - this.x) < 40 && 
                    Math.abs(p.y - this.y) < 40
                );
                
                if (plant) {
                    if (Date.now() - this.lastAttack > 1000) {
                        plant.health -= this.damage;
                        this.lastAttack = Date.now();
                        createParticles(plant.x, plant.y, 'üí•');
                    }
                }
                
                // Check if zombie reached the house
                if (this.x < 0) {
                    gameState.gameOver = true;
                    showGameOver();
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Health bar
                const healthPercent = this.health / this.maxHealth;
                ctx.fillStyle = healthPercent > 0.5 ? '#4CAF50' : healthPercent > 0.25 ? '#FFC107' : '#F44336';
                ctx.fillRect(-20, -35, 40 * healthPercent, 5);
                ctx.strokeStyle = '#333';
                ctx.strokeRect(-20, -35, 40, 5);
                
                // Zombie with costume and dancing animation
                ctx.font = '25px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const dance = Math.sin(this.animation * 2) * 5;
                const wobble = Math.cos(this.animation * 3) * 3;
                ctx.fillText('üßü', wobble, dance);
                ctx.font = '15px Arial';
                ctx.fillText(this.costume, wobble, dance + 20);
                
                ctx.restore();
            }
        }

        // Projectile class
        class Projectile {
            constructor(x, y, target) {
                this.x = x;
                this.y = y;
                this.target = target;
                this.speed = 8;
                this.damage = 20;
            }

            update() {
                this.x += this.speed;
                
                // Check collision with target
                if (this.target && Math.abs(this.x - this.target.x) < 30 && 
                    Math.abs(this.y - this.target.y) < 30) {
                    this.target.health -= this.damage;
                    createParticles(this.x, this.y, 'üí•');
                    return true; // Remove projectile
                }
                
                // Remove if off screen
                if (this.x > canvas.width) return true;
                
                return false;
            }

            draw() {
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Sun class
        class Sun {
            constructor(x, y, fromSky = false) {
                this.x = x;
                this.y = y;
                this.targetY = fromSky ? y + Math.random() * 200 : y;
                this.value = 25;
                this.lifetime = 10000;
                this.created = Date.now();
                this.collected = false;
                this.animation = 0;
            }

            update() {
                this.animation += 0.1;
                
                if (this.y < this.targetY) {
                    this.y += 2;
                }
                
                // Check if expired
                if (Date.now() - this.created > this.lifetime) {
                    return true; // Remove sun
                }
                
                return false;
            }

            draw() {
                const opacity = Math.max(0, 1 - (Date.now() - this.created) / this.lifetime);
                ctx.save();
                ctx.globalAlpha = opacity;
                ctx.font = '25px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const pulse = Math.sin(this.animation) * 2;
                ctx.fillText('‚òÄÔ∏è', this.x, this.y + pulse);
                ctx.restore();
            }
        }

        // Particle effects
        function createParticles(x, y, emoji) {
            for (let i = 0; i < 5; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    emoji: emoji,
                    lifetime: 1000,
                    created: Date.now()
                });
            }
        }

        function updateParticles() {
            gameState.particles = gameState.particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += 0.1; // gravity
                
                return Date.now() - particle.created < particle.lifetime;
            });
        }

        function drawParticles() {
            gameState.particles.forEach(particle => {
                const opacity = Math.max(0, 1 - (Date.now() - particle.created) / particle.lifetime);
                ctx.save();
                ctx.globalAlpha = opacity;
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(particle.emoji, particle.x, particle.y);
                ctx.restore();
            });
        }

        // Game functions
        function spawnZombie() {
            if (Date.now() - gameState.lastZombieSpawn > gameState.zombieSpawnRate) {
                const lane = Math.floor(Math.random() * GRID_ROWS);
                gameState.zombies.push(new Zombie(lane));
                gameState.lastZombieSpawn = Date.now();
                
                // Increase difficulty
                if (gameState.zombies.length % 10 === 0) {
                    gameState.wave++;
                    gameState.zombieSpawnRate = Math.max(2000, gameState.zombieSpawnRate - 200);
                }
            }
        }

        function spawnSun() {
            if (Date.now() - gameState.lastSunSpawn > gameState.sunSpawnRate) {
                const x = Math.random() * canvas.width;
                gameState.suns.push(new Sun(x, -50, true));
                gameState.lastSunSpawn = Date.now();
            }
        }

        function updateGame() {
            if (gameState.gameOver) return;
            
            spawnZombie();
            spawnSun();
            
            // Update all game objects
            gameState.plants.forEach(plant => plant.update());
            gameState.zombies = gameState.zombies.filter(zombie => {
                zombie.update();
                if (zombie.health <= 0) {
                    gameState.score += 10;
                    createParticles(zombie.x, zombie.y, 'üíÄ');
                    return false;
                }
                return true;
            });
            gameState.projectiles = gameState.projectiles.filter(projectile => !projectile.update());
            gameState.suns = gameState.suns.filter(sun => !sun.update());
            updateParticles();
            
            // Remove dead plants
            gameState.plants = gameState.plants.filter(plant => plant.health > 0);
            
            updateUI();
        }

        function drawGame() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL_WIDTH, 0);
                ctx.lineTo(i * CELL_WIDTH, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= GRID_ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * CELL_HEIGHT);
                ctx.lineTo(canvas.width, i * CELL_HEIGHT);
                ctx.stroke();
            }
            
            // Draw game objects
            gameState.plants.forEach(plant => plant.draw());
            gameState.zombies.forEach(zombie => zombie.draw());
            gameState.projectiles.forEach(projectile => projectile.draw());
            gameState.suns.forEach(sun => sun.draw());
            drawParticles();
        }

        function gameLoop() {
            updateGame();
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        function updateUI() {
            document.getElementById('sunCount').textContent = gameState.sun;
            document.getElementById('waveCount').textContent = gameState.wave;
            document.getElementById('scoreCount').textContent = gameState.score;
        }

        function showGameOver() {
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOver').style.display = 'block';
        }

        function restartGame() {
            gameState = {
                sun: 50,
                wave: 1,
                score: 0,
                selectedPlant: 'peashooter',
                gameOver: false,
                plants: [],
                zombies: [],
                projectiles: [],
                suns: [],
                particles: [],
                lastZombieSpawn: 0,
                lastSunSpawn: 0,
                zombieSpawnRate: 5000,
                sunSpawnRate: 10000
            };
            document.getElementById('gameOver').style.display = 'none';
            updateUI();
        }

        // Event listeners
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if clicking on sun
            const clickedSun = gameState.suns.find(sun => 
                Math.abs(sun.x - x) < 20 && Math.abs(sun.y - y) < 20
            );
            
            if (clickedSun) {
                gameState.sun += clickedSun.value;
                gameState.suns = gameState.suns.filter(s => s !== clickedSun);
                createParticles(clickedSun.x, clickedSun.y, '‚ú®');
                return;
            }
            
            // Place plant
            const gridX = Math.floor(x / CELL_WIDTH) * CELL_WIDTH;
            const gridY = Math.floor(y / CELL_HEIGHT) * CELL_HEIGHT;
            
            // Check if spot is empty
            const spotOccupied = gameState.plants.some(plant => 
                plant.x === gridX && plant.y === gridY
            );
            
            if (!spotOccupied) {
                const plantType = gameState.selectedPlant;
                const cost = plantTypes[plantType].cost;
                
                if (gameState.sun >= cost) {
                    gameState.plants.push(new Plant(gridX, gridY, plantType));
                    gameState.sun -= cost;
                    createParticles(gridX + CELL_WIDTH/2, gridY + CELL_HEIGHT/2, 'üå±');
                }
            }
        });

        // Plant selector buttons
        document.querySelectorAll('.plant-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.plant-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                gameState.selectedPlant = btn.dataset.plant;
            });
        });

        // Start game
        gameLoop();
    </script>
</body>
</html>