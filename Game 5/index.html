<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Food Fight Frenzy</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(135deg, #ff9a00 0%, #ff5e62 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
            color: white;
        }

        .game-title {
            font-size: 2.5em;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
            margin-bottom: 10px;
            animation: splat 3s infinite;
        }

        @keyframes splat {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.05) rotate(-2deg); }
            50% { transform: scale(1.1) rotate(2deg); }
            75% { transform: scale(1.05) rotate(-1deg); }
        }

        .game-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 1.2em;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .player-stats {
            display: flex;
            gap: 20px;
        }

        .player-info {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 10px;
            min-width: 120px;
        }

        .player-info.player1 {
            background: rgba(255, 100, 100, 0.3);
        }

        .player-info.player2 {
            background: rgba(100, 100, 255, 0.3);
        }

        .location-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
        }

        .location-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #ff9a00 0%, #ff5e62 100%);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .location-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .location-btn.selected {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            transform: scale(1.1);
        }

        canvas {
            border: 3px solid #fff;
            border-radius: 10px;
            display: block;
            background: linear-gradient(to bottom, #fff5e6 0%, #ffe0b2 100%);
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 1000;
        }

        .game-over h2 {
            font-size: 2em;
            margin-bottom: 20px;
            color: #ff6b6b;
        }

        .restart-btn {
            padding: 15px 30px;
            font-size: 1.2em;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #ff9a00 0%, #ff5e62 100%);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .restart-btn:hover {
            transform: scale(1.05);
        }

        .controls {
            text-align: center;
            margin-top: 15px;
            color: white;
            font-size: 1.1em;
        }

        .food-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .food-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.2em;
        }

        .food-btn:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.5);
        }

        .food-btn.selected {
            background: rgba(255, 255, 255, 0.7);
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .power-ups {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
        }

        .power-up-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .power-up-btn:hover {
            transform: scale(1.05);
        }

        .power-up-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .health-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            margin-top: 5px;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #27ae60 0%, #2ecc71 100%);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .ammo-indicator {
            display: flex;
            gap: 5px;
            margin-top: 5px;
            justify-content: center;
        }

        .ammo-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
        }

        .ammo-dot.filled {
            background: #fff;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">üçï Food Fight Frenzy üåÆ</h1>
            <div class="game-stats">
                <div class="player-stats">
                    <div class="player-info player1">
                        <div>üî¥ Player 1</div>
                        <div>Score: <span id="player1Score">0</span></div>
                        <div class="health-bar">
                            <div class="health-fill" id="player1Health" style="width: 100%"></div>
                        </div>
                        <div class="ammo-indicator" id="player1Ammo">
                            <div class="ammo-dot filled"></div>
                            <div class="ammo-dot filled"></div>
                            <div class="ammo-dot filled"></div>
                        </div>
                    </div>
                    <div class="player-info player2">
                        <div>üîµ Player 2</div>
                        <div>Score: <span id="player2Score">0</span></div>
                        <div class="health-bar">
                            <div class="health-fill" id="player2Health" style="width: 100%"></div>
                        </div>
                        <div class="ammo-indicator" id="player2Ammo">
                            <div class="ammo-dot filled"></div>
                            <div class="ammo-dot filled"></div>
                            <div class="ammo-dot filled"></div>
                        </div>
                    </div>
                </div>
                <div>‚è±Ô∏è Time: <span id="timeCount">60</span></div>
            </div>
            <div class="location-selector">
                <button class="location-btn selected" data-location="cafeteria">üè´ School Cafeteria</button>
                <button class="location-btn" data-location="restaurant">üçΩÔ∏è Fancy Restaurant</button>
                <button class="location-btn" data-location="foodtruck">üöö Food Truck Festival</button>
                <button class="location-btn" data-location="supermarket">üõí Supermarket</button>
            </div>
            <div class="food-selector">
                <button class="food-btn selected" data-food="spaghetti">üçù</button>
                <button class="food-btn" data-food="meatball">üçñ</button>
                <button class="food-btn" data-food="pie">ü•ß</button>
                <button class="food-btn" data-food="ketchup">üçÖ</button>
                <button class="food-btn" data-food="hotdog">üå≠</button>
                <button class="food-btn" data-food="pizza">üçï</button>
            </div>
            <div class="power-ups">
                <button class="power-up-btn" id="supersizeBtn">üî• Supersize (2)</button>
                <button class="power-up-btn" id="rapidfireBtn">‚ö° Rapid Fire (2)</button>
                <button class="power-up-btn" id="shieldBtn">üõ°Ô∏è Shield (1)</button>
            </div>
        </div>
        <canvas id="gameCanvas" width="900" height="600"></canvas>
        <div class="controls">
            <p>üéÆ Player 1: WASD to move, SPACE to throw | Player 2: Arrow keys to move, ENTER to throw</p>
            <p>üéØ Hit your opponent with food! Avoid the chefs and janitors!</p>
        </div>
        <div class="game-over" id="gameOver">
            <h2 id="gameOverTitle">Game Over!</h2>
            <p id="gameOverMessage"></p>
            <button class="restart-btn" onclick="restartGame()">Food Fight Again!</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameState = {
            player1Score: 0,
            player2Score: 0,
            player1Health: 100,
            player2Health: 100,
            player1Ammo: 3,
            player2Ammo: 3,
            timeLeft: 60,
            gameOver: false,
            currentLocation: 'cafeteria',
            selectedFood: 'spaghetti',
            player1PowerUps: { supersize: 2, rapidfire: 2, shield: 1 },
            player2PowerUps: { supersize: 2, rapidfire: 2, shield: 1 },
            player1Supersize: false,
            player2Supersize: false,
            player1Rapidfire: false,
            player2Rapidfire: false,
            player1Shield: false,
            player2Shield: false,
            particles: [],
            foodProjectiles: [],
            enemies: [],
            obstacles: [],
            startTime: Date.now(),
            lastAmmoRefill: Date.now()
        };

        // Food types
        const foodTypes = {
            spaghetti: { emoji: 'üçù', damage: 15, speed: 6, size: 20, effect: 'slow' },
            meatball: { emoji: 'üçñ', damage: 20, speed: 5, size: 25, effect: 'stun' },
            pie: { emoji: 'ü•ß', damage: 25, speed: 4, size: 30, effect: 'blind' },
            ketchup: { emoji: 'üçÖ', damage: 10, speed: 8, size: 15, effect: 'damage' },
            hotdog: { emoji: 'üå≠', damage: 18, speed: 7, size: 22, effect: 'knockback' },
            pizza: { emoji: 'üçï', damage: 22, speed: 5, size: 28, effect: 'area' }
        };

        // Location configurations
        const locations = {
            cafeteria: {
                name: 'School Cafeteria',
                obstacles: [
                    { x: 200, y: 150, width: 80, height: 60, emoji: 'üçΩÔ∏è' },
                    { x: 500, y: 200, width: 100, height: 40, emoji: 'ü•ó' },
                    { x: 350, y: 400, width: 120, height: 50, emoji: 'üçï' },
                    { x: 650, y: 350, width: 60, height: 60, emoji: 'ü•§' }
                ],
                enemies: ['chef', 'janitor']
            },
            restaurant: {
                name: 'Fancy Restaurant',
                obstacles: [
                    { x: 150, y: 180, width: 100, height: 80, emoji: 'üç∑' },
                    { x: 400, y: 150, width: 80, height: 100, emoji: 'üçΩÔ∏è' },
                    { x: 600, y: 300, width: 90, height: 70, emoji: 'üç∞' },
                    { x: 300, y: 450, width: 110, height: 40, emoji: 'ü´ñ' }
                ],
                enemies: ['waiter', 'chef']
            },
            foodtruck: {
                name: 'Food Truck Festival',
                obstacles: [
                    { x: 100, y: 200, width: 120, height: 80, emoji: 'üöö' },
                    { x: 400, y: 100, width: 100, height: 120, emoji: 'üåÆ' },
                    { x: 650, y: 250, width: 80, height: 80, emoji: 'üçî' },
                    { x: 250, y: 400, width: 90, height: 60, emoji: 'üç¶' }
                ],
                enemies: ['vendor', 'customer']
            },
            supermarket: {
                name: 'Supermarket',
                obstacles: [
                    { x: 200, y: 120, width: 150, height: 60, emoji: 'üõí' },
                    { x: 500, y: 200, width: 80, height: 100, emoji: 'ÔøΩÔøΩ' },
                    { x: 350, y: 350, width: 100, height: 80, emoji: 'ü•´' },
                    { x: 600, y: 400, width: 70, height: 70, emoji: 'üçû' }
                ],
                enemies: ['cashier', 'security']
            }
        };

        // Player class
        class Player {
            constructor(x, y, color, controls) {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.color = color;
                this.controls = controls;
                this.speed = 4;
                this.health = 100;
                this.score = 0;
                this.ammo = 3;
                this.facing = 'right';
                this.animation = 0;
                this.throwCooldown = 0;
                this.effects = [];
            }

            update() {
                this.animation += 0.1;
                
                if (this.throwCooldown > 0) {
                    this.throwCooldown--;
                }
                
                // Update effects
                this.effects = this.effects.filter(effect => {
                    effect.duration--;
                    return effect.duration > 0;
                });
                
                // Apply movement modifiers
                let speedModifier = 1;
                if (this.effects.some(e => e.type === 'slow')) {
                    speedModifier = 0.5;
                }
                
                this.speed = 4 * speedModifier;
            }

            move(dx, dy) {
                this.x += dx * this.speed;
                this.y += dy * this.speed;
                
                // Keep player in bounds
                this.x = Math.max(20, Math.min(canvas.width - 20, this.x));
                this.y = Math.max(20, Math.min(canvas.height - 20, this.y));
                
                // Update facing direction
                if (dx > 0) this.facing = 'right';
                else if (dx < 0) this.facing = 'left';
                
                // Check obstacle collisions
                const location = locations[gameState.currentLocation];
                location.obstacles.forEach(obstacle => {
                    if (this.rectCollision(this, obstacle)) {
                        this.x -= dx * this.speed;
                        this.y -= dy * this.speed;
                    }
                });
            }

            throwFood() {
                if (this.throwCooldown > 0 || this.ammo <= 0) return null;
                
                const food = foodTypes[gameState.selectedFood];
                const projectile = new FoodProjectile(
                    this.x,
                    this.y,
                    this.facing === 'right' ? food.speed : -food.speed,
                    0,
                    food,
                    this
                );
                
                this.ammo--;
                this.throwCooldown = this === player1 && gameState.player1Rapidfire ? 10 : 30;
                
                return projectile;
            }

            takeDamage(damage) {
                if (this === player1 && gameState.player1Shield) {
                    gameState.player1Shield = false;
                    createParticles(this.x, this.y, 'üõ°Ô∏è');
                    return;
                }
                if (this === player2 && gameState.player2Shield) {
                    gameState.player2Shield = false;
                    createParticles(this.x, this.y, 'üõ°Ô∏è');
                    return;
                }
                
                this.health -= damage;
                createParticles(this.x, this.y, 'üí•');
            }

            addEffect(type, duration) {
                this.effects.push({ type, duration });
            }

            rectCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Draw shield if active
                if ((this === player1 && gameState.player1Shield) || 
                    (this === player2 && gameState.player2Shield)) {
                    ctx.strokeStyle = 'rgba(0, 100, 255, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, 30, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Draw player
                const wobble = Math.sin(this.animation) * 2;
                ctx.font = `${this === player1 && gameState.player1Supersize ? 40 : 30}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this === player1 ? 'üë®' : 'üë©', 0, wobble);
                
                // Draw facing indicator
                ctx.font = '20px Arial';
                ctx.fillText(this.facing === 'right' ? 'üëâ' : 'üëà', this.facing === 'right' ? 20 : -20, 0);
                
                ctx.restore();
            }
        }

        // Food projectile class
        class FoodProjectile {
            constructor(x, y, vx, vy, food, owner) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.food = food;
                this.owner = owner;
                this.size = owner === player1 && gameState.player1Supersize ? food.size * 1.5 : 
                           owner === player2 && gameState.player2Supersize ? food.size * 1.5 : food.size;
                this.rotation = 0;
                this.trail = [];
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.rotation += 0.1;
                
                // Add to trail
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 5) {
                    this.trail.shift();
                }
                
                // Apply gravity
                this.vy += 0.2;
                
                // Check if out of bounds
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    return true; // Remove projectile
                }
                
                // Check obstacle collisions
                const location = locations[gameState.currentLocation];
                for (let obstacle of location.obstacles) {
                    if (this.circleRectCollision(this, obstacle)) {
                        createParticles(this.x, this.y, this.food.emoji);
                        return true; // Remove projectile
                    }
                }
                
                return false;
            }

            circleRectCollision(circle, rect) {
                const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
                const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));
                const distance = Math.sqrt(Math.pow(circle.x - closestX, 2) + Math.pow(circle.y - closestY, 2));
                return distance < this.size;
            }

            draw() {
                // Draw trail
                this.trail.forEach((point, index) => {
                    ctx.save();
                    ctx.globalAlpha = index / this.trail.length * 0.5;
                    ctx.font = `${this.size * 0.8}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.food.emoji, point.x, point.y);
                    ctx.restore();
                });
                
                // Draw projectile
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.font = `${this.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.food.emoji, 0, 0);
                ctx.restore();
            }
        }

        // Enemy class
        class Enemy {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.speed = 1;
                this.direction = 1;
                this.patrolStart = x - 100;
                this.patrolEnd = x + 100;
                this.animation = 0;
                this.emoji = this.getEmoji();
            }

            getEmoji() {
                const emojis = {
                    chef: 'üë®‚Äçüç≥',
                    janitor: 'üßπ',
                    waiter: 'üßë‚ÄçüçΩÔ∏è',
                    vendor: 'üë®‚Äçüç≥',
                    customer: 'üë§',
                    cashier: 'üë©‚Äçüíº',
                    security: 'üëÆ'
                };
                return emojis[this.type] || 'üë§';
            }

            update() {
                this.animation += 0.05;
                this.x += this.speed * this.direction;
                
                if (this.x <= this.patrolStart || this.x >= this.patrolEnd) {
                    this.direction *= -1;
                }
                
                // Check for player collisions
                [player1, player2].forEach(player => {
                    if (this.rectCollision(this, player)) {
                        player.takeDamage(10);
                        createParticles(player.x, player.y, 'üòµ');
                    }
                });
            }

            rectCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                const walk = Math.sin(this.animation) * 2;
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, 0, walk);
                
                ctx.restore();
            }
        }

        // Initialize game objects
        let player1 = new Player(100, 300, 'red', { up: 'w', down: 's', left: 'a', right: 'd', throw: ' ' });
        let player2 = new Player(800, 300, 'blue', { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight', throw: 'Enter' });

        // Initialize enemies
        function initializeEnemies() {
            gameState.enemies = [];
            const location = locations[gameState.currentLocation];
            const enemyTypes = location.enemies;
            
            enemyTypes.forEach((type, index) => {
                const x = 200 + index * 250;
                const y = 150 + index * 100;
                gameState.enemies.push(new Enemy(type, x, y));
            });
        }

        // Particle effects
        function createParticles(x, y, emoji) {
            for (let i = 0; i < 8; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    emoji: emoji,
                    lifetime: 1000,
                    created: Date.now()
                });
            }
        }

        function updateParticles() {
            gameState.particles = gameState.particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += 0.2;
                particle.vx *= 0.98;
                
                return Date.now() - particle.created < particle.lifetime;
            });
        }

        function drawParticles() {
            gameState.particles.forEach(particle => {
                const opacity = Math.max(0, 1 - (Date.now() - particle.created) / particle.lifetime);
                ctx.save();
                ctx.globalAlpha = opacity;
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(particle.emoji, particle.x, particle.y);
                ctx.restore();
            });
        }

        // Game functions
        function updateGame() {
            if (gameState.gameOver) return;
            
            // Update time
            const currentTime = Date.now();
            const elapsed = Math.floor((currentTime - gameState.startTime) / 1000);
            gameState.timeLeft = Math.max(0, 60 - elapsed);
            
            if (gameState.timeLeft <= 0) {
                endGame();
                return;
            }
            
            // Refill ammo every 5 seconds
            if (currentTime - gameState.lastAmmoRefill > 5000) {
                player1.ammo = Math.min(3, player1.ammo + 1);
                player2.ammo = Math.min(3, player2.ammo + 1);
                gameState.lastAmmoRefill = currentTime;
            }
            
            // Update players
            player1.update();
            player2.update();
            
            // Update projectiles
            gameState.foodProjectiles = gameState.foodProjectiles.filter(projectile => {
                const shouldRemove = projectile.update();
                
                if (!shouldRemove) {
                    // Check player collisions
                    if (projectile.owner === player1) {
                        if (checkCollision(projectile, player2)) {
                            player2.takeDamage(projectile.food.damage);
                            player1.score += 10;
                            applyFoodEffect(player2, projectile.food);
                            createParticles(projectile.x, projectile.y, projectile.food.emoji);
                            return true;
                        }
                    } else {
                        if (checkCollision(projectile, player1)) {
                            player1.takeDamage(projectile.food.damage);
                            player2.score += 10;
                            applyFoodEffect(player1, projectile.food);
                            createParticles(projectile.x, projectile.y, projectile.food.emoji);
                            return true;
                        }
                    }
                }
                
                return shouldRemove;
            });
            
            // Update enemies
            gameState.enemies.forEach(enemy => enemy.update());
            
            // Update particles
            updateParticles();
            
            // Update game state
            gameState.player1Health = player1.health;
            gameState.player2Health = player2.health;
            gameState.player1Score = player1.score;
            gameState.player2Score = player2.score;
            gameState.player1Ammo = player1.ammo;
            gameState.player2Ammo = player2.ammo;
            
            // Check win conditions
            if (player1.health <= 0) {
                endGame('Player 2 Wins! üéâ');
            } else if (player2.health <= 0) {
                endGame('Player 1 Wins! üéâ');
            }
            
            updateUI();
        }

        function checkCollision(projectile, player) {
            const distance = Math.sqrt(Math.pow(projectile.x - player.x, 2) + Math.pow(projectile.y - player.y, 2));
            return distance < projectile.size + 20;
        }

        function applyFoodEffect(player, food) {
            switch (food.effect) {
                case 'slow':
                    player.addEffect('slow', 120);
                    break;
                case 'stun':
                    player.addEffect('stun', 60);
                    break;
                case 'blind':
                    player.addEffect('blind', 90);
                    break;
                case 'knockback':
                    player.x += player === player1 ? 30 : -30;
                    break;
                case 'area':
                    // Area damage would affect nearby players
                    break;
            }
        }

        function drawGame() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw floor
            ctx.fillStyle = '#fff5e6';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw floor pattern
            ctx.fillStyle = 'rgba(255, 200, 150, 0.3)';
            for (let x = 0; x < canvas.width; x += 50) {
                for (let y = 0; y < canvas.height; y += 50) {
                    if ((x + y) % 100 === 0) {
                        ctx.fillRect(x, y, 50, 50);
                    }
                }
            }
            
            // Draw obstacles
            const location = locations[gameState.currentLocation];
            location.obstacles.forEach(obstacle => {
                ctx.font = `${Math.min(obstacle.width, obstacle.height)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(obstacle.emoji, obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2);
            });
            
            // Draw enemies
            gameState.enemies.forEach(enemy => enemy.draw());
            
            // Draw projectiles
            gameState.foodProjectiles.forEach(projectile => projectile.draw());
            
            // Draw players
            player1.draw();
            player2.draw();
            
            // Draw particles
            drawParticles();
            
            // Draw location name
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(location.name, canvas.width / 2, 30);
        }

        function gameLoop() {
            updateGame();
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        function updateUI() {
            document.getElementById('player1Score').textContent = gameState.player1Score;
            document.getElementById('player2Score').textContent = gameState.player2Score;
            document.getElementById('timeCount').textContent = gameState.timeLeft;
            
            // Update health bars
            document.getElementById('player1Health').style.width = `${gameState.player1Health}%`;
            document.getElementById('player2Health').style.width = `${gameState.player2Health}%`;
            
            // Update ammo indicators
            const player1AmmoDots = document.querySelectorAll('#player1Ammo .ammo-dot');
            const player2AmmoDots = document.querySelectorAll('#player2Ammo .ammo-dot');
            
            player1AmmoDots.forEach((dot, index) => {
                dot.classList.toggle('filled', index < gameState.player1Ammo);
            });
            
            player2AmmoDots.forEach((dot, index) => {
                dot.classList.toggle('filled', index < gameState.player2Ammo);
            });
            
            // Update power-up buttons
            document.getElementById('supersizeBtn').textContent = `üî• Supersize (${gameState.player1PowerUps.supersize})`;
            document.getElementById('rapidfireBtn').textContent = `‚ö° Rapid Fire (${gameState.player1PowerUps.rapidfire})`;
            document.getElementById('shieldBtn').textContent = `üõ°Ô∏è Shield (${gameState.player1PowerUps.shield})`;
        }

        function endGame(message) {
            gameState.gameOver = true;
            
            if (!message) {
                if (gameState.player1Score > gameState.player2Score) {
                    message = 'Player 1 Wins! üéâ';
                } else if (gameState.player2Score > gameState.player1Score) {
                    message = 'Player 2 Wins! üéâ';
                } else {
                    message = "It's a Tie! ü§ù";
                }
            }
            
            document.getElementById('gameOverTitle').textContent = 'Food Fight Complete!';
            document.getElementById('gameOverMessage').innerHTML = `
                ${message}<br>
                Player 1 Score: ${gameState.player1Score}<br>
                Player 2 Score: ${gameState.player2Score}
            `;
            document.getElementById('gameOver').style.display = 'block';
        }

        function restartGame() {
            gameState = {
                player1Score: 0,
                player2Score: 0,
                player1Health: 100,
                player2Health: 100,
                player1Ammo: 3,
                player2Ammo: 3,
                timeLeft: 60,
                gameOver: false,
                currentLocation: gameState.currentLocation,
                selectedFood: gameState.selectedFood,
                player1PowerUps: { supersize: 2, rapidfire: 2, shield: 1 },
                player2PowerUps: { supersize: 2, rapidfire: 2, shield: 1 },
                player1Supersize: false,
                player2Supersize: false,
                player1Rapidfire: false,
                player2Rapidfire: false,
                player1Shield: false,
                player2Shield: false,
                particles: [],
                foodProjectiles: [],
                enemies: [],
                obstacles: [],
                startTime: Date.now(),
                lastAmmoRefill: Date.now()
            };
            
            player1 = new Player(100, 300, 'red', { up: 'w', down: 's', left: 'a', right: 'd', throw: ' ' });
            player2 = new Player(800, 300, 'blue', { up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight', throw: 'Enter' });
            
            initializeEnemies();
            
            document.getElementById('gameOver').style.display = 'none';
            updateUI();
        }

        // Input handling
        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            // Handle throwing
            if (e.key === ' ') {
                e.preventDefault();
                const projectile = player1.throwFood();
                if (projectile) {
                    gameState.foodProjectiles.push(projectile);
                }
            }
            if (e.key === 'Enter') {
                e.preventDefault();
                const projectile = player2.throwFood();
                if (projectile) {
                    gameState.foodProjectiles.push(projectile);
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        function handleInput() {
            // Player 1 movement
            if (keys['w']) player1.move(0, -1);
            if (keys['s']) player1.move(0, 1);
            if (keys['a']) player1.move(-1, 0);
            if (keys['d']) player1.move(1, 0);
            
            // Player 2 movement
            if (keys['arrowup']) player2.move(0, -1);
            if (keys['arrowdown']) player2.move(0, 1);
            if (keys['arrowleft']) player2.move(-1, 0);
            if (keys['arrowright']) player2.move(1, 0);
        }

        // Location selector
        document.querySelectorAll('.location-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.location-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                gameState.currentLocation = btn.dataset.location;
                initializeEnemies();
            });
        });

        // Food selector
        document.querySelectorAll('.food-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.food-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                gameState.selectedFood = btn.dataset.food;
            });
        });

        // Power-up buttons
        document.getElementById('supersizeBtn').addEventListener('click', () => {
            if (gameState.player1PowerUps.supersize > 0) {
                gameState.player1PowerUps.supersize--;
                gameState.player1Supersize = true;
                createParticles(player1.x, player1.y, 'üî•');
                
                setTimeout(() => {
                    gameState.player1Supersize = false;
                }, 5000);
            }
        });

        document.getElementById('rapidfireBtn').addEventListener('click', () => {
            if (gameState.player1PowerUps.rapidfire > 0) {
                gameState.player1PowerUps.rapidfire--;
                gameState.player1Rapidfire = true;
                createParticles(player1.x, player1.y, '‚ö°');
                
                setTimeout(() => {
                    gameState.player1Rapidfire = false;
                }, 3000);
            }
        });

        document.getElementById('shieldBtn').addEventListener('click', () => {
            if (gameState.player1PowerUps.shield > 0) {
                gameState.player1PowerUps.shield--;
                gameState.player1Shield = true;
                createParticles(player1.x, player1.y, 'üõ°Ô∏è');
            }
        });

        // Initialize game
        initializeEnemies();
        
        // Modified game loop to include input handling
        function enhancedGameLoop() {
            handleInput();
            updateGame();
            drawGame();
            requestAnimationFrame(enhancedGameLoop);
        }
        
        enhancedGameLoop();
    </script>
</body>
</html>